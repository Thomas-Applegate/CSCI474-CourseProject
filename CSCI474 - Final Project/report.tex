\documentclass[11pt,letterpaper,conference]{IEEEtran}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{float}
\usepackage[english]{babel}
%proper format of quotations
\usepackage{csquotes}
%load biblatex for bibliography processing and reference management
%use the ieee style for citations.
\usepackage[style=ieee]{biblatex}
%prevent bad hboxes when formating urls
\usepackage{xurl}

\MakeOuterQuote{"}

% new line command in order to align authors better
% found here https://tex.stackexchange.com/questions/458204/ieeetran-document-class-how-to-align-five-authors-properly/458208#458208
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}

%set graphics path where figures will be loaded from.
\graphicspath{ {images/} }

%load bibliography
%this is the file wehre all citations are stored. Latex will figure out the order
%dynamically when it compiles the document
\addbibresource{refs.bib}

\begin{document}

\title{NIST Randomness Tests vs Pseudo Random Classes}

\author{\IEEEauthorblockN{Thomas Applegate}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
tapplegate@mines.edu}
%
\and
%
\IEEEauthorblockN{Kaelyn Boutin}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
kvboutin@mines.edu}
%
\and
%
\IEEEauthorblockN{Gabrielle Nadia Hadi}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
ghadi@mines.edu}
%
%\and
\linebreakand
%
\IEEEauthorblockN{Addison Hart}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
addisonhart@mines.edu}
%
\and
%
\IEEEauthorblockN{ET Griffin}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
egriffin@mines.edu}
%
\and
%
\IEEEauthorblockN{Isabelle Neckel}
\IEEEauthorblockA{\textit{Colorado School of Mines} \\
Golden, CO, USA \\
ineckel@mines.edu}
}

\maketitle

\begin{abstract}
The National Institute of Standards and Technology, NIST, defines fifteen separate tests
for the randomness and unpredictability of random numbers \cite{nistbook}. True Random, Deskewed True
Random and Pseudorandom are the three classes of random numbers that are going to be
compared using the tests outlined by NIST. We plan to use a Python implementation that will
provide us the P-values to compare and contrast to determine the random numbers that are
closest to being truly random. The generation of the random numbers will also be considered
when discussing the choice in relation to cryptography.
\end{abstract}

\begin{IEEEkeywords}
random numbers, pseudorandomness, NIST, python
\end{IEEEkeywords}

\section{Introduction}
Random number and bit generation is used heavily in cryptography and security applications, but it
is really difficult to get truly random numbers. So the SP 800 90 created and provided guidelines for
the generation of random numbers for cryptographic use. There are 3 parts to the SP 800 90 series,
90A talks about mechanism for the generation of random bits using deterministic methods, 90B
has discussion about how valid certain ideas of randomness and entropy are, and finally 90c
specifically talks about construction and implementation of random bit generators. Random Bit
Generation must be checked for randomness, so a total of fifteen statistical tests were developed
and evaluated in order to determine the validity of a generator’s statistical randomness. The fifteen
tests are as follows

\begin{enumerate}
\item Frequency (monobits) tests: This test determines whether the number of ones and zeros generated in a sequence are approximately the same as should be generated for a true random sequence.
\item Test for Frequency Within a Block: This test tries to determine if the frequency of ones in a M-bit block is approximately half the size of the block.
\item Runs Test: This test determines whether switching between substrings is too fast or slow.
\item Test For Longest Run of Ones in a Block: This test determines if the longest runs of ones in a block is similar to the longest run in a truly random generation.
\item Random Binary Matrix Rank Test: This test checks for linear dependence in a fixed length substring.
\item Discrete Fourier Transform (Spectral) Test: This test detects periodic features that could indicate the lack of randomness.
\item Non-Overlapping (Aperiodic) Template Matching Test: This test is used to reject sequence that show too many occurrences of a given non-periodic pattern (similar to the zero’s run but allows for statistical independence amongst tests).
\item Overlapping (Periodic) Template Matching Test: This test is used to reject sequence that show changes from the expected number of runs of ones of a given length.
\item Maurer's Universal Statistical Test: This test detects whether or not a sequence can be compressed without loss of information, a overly compressible sequence is considered non-random.
\item Linear Complexity Test: This test determines if a sequence is complex enough to be considered random.
\item Serial Test: The test determines the number of occurrences of 2m m-bit overlapping patterns is what should be expected for a random sequence.
\item Approximate Entropy Test: This test compares the frequency of overlapping blocks of conservative lengths against what is expected for a random sequence.
\item Cumulative Sum (Cusum) Test: This test determines if the cumulative sum of partial sequence in the test sequences are too large or too small relative to random sequences.
\item Random Excursions Test: This test is used to determine if a number of visits to a state within a random walk except what is expected for a random sequence.
\item Random Excursions Variant Test: This test detects deviation from the expected number of occurrences of various states in a random walk.
\end{enumerate}

There are multiple random generators that pass these tests, but how much do these random
generators pass by. Why is that important or interesting for randomness. These are all interesting
questions that could be researched by trying these fifteen tests are a few generators and reading
into the results.

The goal of this research is to compare and contrast different random generators using these fifteen tests. Our research will compare True Random, Deskewed True Random, and Pseudorandom, to see how these classes stack up against one another and compare the time cost of each.

%\section{Methods}
%To test the randomness of various algorithms, we will use the NIST randomness tests as
%implemented in Python \cite{rtestsuite}. The tests require a binary string of indeterminate length as the input.
%Each of the fifteen tests will output the P-value, as well as the result of whether the P-value means
%that the data can be considered truly random or not. For each of the algorithms that we test, we
%will use many samples of equal length to compare their randomness to each other.
\section{Key idea and Approach}
\section{Activities}
\section{Analysis and Observations}

%\section{Expected Results}
%We wish to use this work to prove what algorithms in each class, whether True Random, Deskewed True
%Random or Pseudorandom, consistently perform the best in the NIST randomness tests and are therefore
%relevant in designing cryptographically secure algorithms, as well as what the strengths and weaknesses
%of the different classes are. We also intend to prove why specific classes
%are better suited for certain cryptographic tasks than others. We also intend to show why some algorithms
%necessitate complexity, like hardware input or SHA hashing, and which algorithms are unnecessarily
%computationally intensive or complicated for the quality of their output.


\section{Limitations}
\section{Potential Future Work}
\section{Conclusion}
NIST provides 15 tests to compare and contrast random number generators. These tests promote different qualities of ideal random numbers. The team plans to use python libraries for the NIST tests, and various pseudorandom and deskewed true random number generating algorithms to compare them to true random numbers. We will summarize the results of these comparisons, and then advise on the generating algorithms suitable for cryptographic use.




\printbibliography[heading=bibintoc, title={References}]

\end{document}
